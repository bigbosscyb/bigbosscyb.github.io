[{"content":"凭着我对c#语言的理解，我写出了如下代码：目的是将平整结构的集合，转化成层级结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; class Node { public: std::string id; std::string value; std::string pid; std::vector\u0026lt;Node\u0026gt; children; Node(std::string id, std::string value, std::string pid) : id(id), value(value), pid(pid) { } static void BuildTree(std::vector\u0026lt;Node\u0026gt; nodes); }; int main() { std::vector\u0026lt;Node\u0026gt; nodes; nodes.push_back(Node(\u0026#34;1\u0026#34;, \u0026#34;node 1\u0026#34;, \u0026#34;\u0026#34;)); nodes.push_back(Node(\u0026#34;2\u0026#34;, \u0026#34;node 2\u0026#34;, \u0026#34;1\u0026#34;)); nodes.push_back(Node(\u0026#34;3\u0026#34;, \u0026#34;node 3\u0026#34;, \u0026#34;1\u0026#34;)); nodes.push_back(Node(\u0026#34;4\u0026#34;, \u0026#34;node 4\u0026#34;, \u0026#34;2\u0026#34;)); Node::BuildTree(nodes); return 0; } void Node::BuildTree(std::vector\u0026lt;Node\u0026gt; nodes) { std::map\u0026lt;std::string, Node\u0026gt; map; for (auto node: nodes) { map.insert(std::pair\u0026lt;std::string, Node\u0026gt;(node.id, node)); } for (auto node: map) { auto parent = map.find(node.second.pid); if (parent != map.end()) { parent-\u0026gt;second.children.push_back(node.second); } } } 运行下来后，我发现BuildTree方法的nodes并没有发生改变，于是我让Ai帮我分析了一下代码：\n下面是AI的思考：\n用户让我分析这段 C++ 代码有什么不好的地方。首先，我需要仔细看一下代码的结构和功能。这段代码定义了一个 Node 类，用来构建树结构，有 id、value、pid 和 children 成员，还有一个静态方法 BuildTree 来构建树。main 函数里创建了一些节点，然后调用 BuildTree。\n首先，我应该从几个方面检查：内存管理、逻辑错误、效率问题、封装性、const 正确性、传参方式等等。\n先看 BuildTree 函数。它的参数是 std::vector nodes，这是按值传递的，意味着会复制整个 vector，效率不高，尤其是节点多的时候，应该用 const 引用传递，比如 const std::vector\u0026amp; nodes。\n然后，BuildTree 里用 map 存储节点，也是按值存储的。当插入 map 的时候，是复制了 node 对象。之后遍历 map，查找父节点，然后 parent-\u0026gt;second.children.push_back (node.second)，这里又复制了 node.second。这会导致什么问题呢？原来的 nodes vector 里的节点，和 map 里的节点都是副本，所以当我们往 parent 的 children 里添加节点时，其实添加的是 map 中节点的副本，而不是原始节点。这样构建的树结构只是在 map 的副本之间建立关系，函数结束后 map 被销毁，树结构也就不存在了，main 函数里的 nodes 并没有被修改，所以这个 BuildTree 实际上没有任何效果，因为它操作的都是副本，没有修改原始数据。这是一个严重的逻辑错误，因为函数的目的应该是构建树，但最终什么都没留下。\n接下来，Node 类的成员都是 public 的，缺乏封装性。良好的设计应该把成员变量设为 private，通过 public 的 getter 和 setter 来访问，这样可以控制访问权限，保证数据的完整性。\n然后，BuildTree 是静态方法，但是构建树之后，树的根节点或者整个结构没有被返回，也没有被存储到某个地方。main 函数调用后，无法使用构建好的树，因为 BuildTree 没有输出任何结果。应该让 BuildTree 返回根节点或者整个树的结构，或者修改传入的 nodes vector 中的节点。\n另外，在 map 的使用上，插入的时候用 map.insert (std::pair\u0026hellip;)，其实可以用 emplace 或者直接 map [node.id] = node，更简洁。不过这是小问题。\n还有，当遍历 map 的时候，auto node 是 map 的键值对，node.second 是 Node 对象，这时候对 parent-\u0026gt;second.children 添加的是副本，如前所述，导致树结构无法保留。应该存储指针或者引用，而不是值。因为如果存储对象，会有多次复制，而且原始节点不会被修改。\n可能的内存问题：如果使用指针，需要注意所有权，但这里按值存储导致的是逻辑错误，无法构建有效的树结构。\n另外，BuildTree 函数内部构建的树，在函数结束后就销毁了，因为 map 是局部变量，所以整个树结构在函数退出后就不存在了，这使得这个函数没有实际作用。\n还有，Node 的构造函数是 public 的，没问题，但成员变量暴露在外，可能被意外修改，破坏树的结构。\n总结一下主要问题：\n传参方式错误：BuildTree 参数按值传递，导致复制开销大，且操作的是副本。 树结构无法保留：BuildTree 内部操作的是局部 map 中的副本，函数结束后所有修改丢失，原始 nodes 未被修改。 缺乏封装：Node 的成员变量都是 public，不符合封装原则。 函数无返回值：BuildTree 没有返回构建好的树结构，调用者无法使用。 对象复制过多：map 存储的是 Node 副本，添加 children 时又复制，效率低且导致逻辑错误。 可能的空 pid 处理：根节点的 pid 是空字符串，查找时 parent 会是 map.end ()，这部分没问题，但如果有无效的 pid（不存在的 id），也没有错误处理。 需要把这些问题一一指出来，并说明为什么不好，以及可能的改进方向。\n下面是AI的回答\n这段 C++ 代码主要用于构建树形结构，但存在一些设计和逻辑上的问题，具体分析如下：\n1. 传参方式不合理，导致数据复制开销大且逻辑无效 1 static void BuildTree(std::vector\u0026lt;Node\u0026gt; nodes); // 按值传递vector 问题：函数参数使用按值传递（std::vector\u0026lt;Node\u0026gt; nodes），会导致整个容器及其中的Node对象被完整复制。当节点数量较多时，会产生大量冗余复制，浪费内存和 CPU 资源。 更严重的问题：由于传递的是副本，BuildTree内部对nodes的所有操作（包括构建树结构）都仅作用于这个副本，而非main函数中原始的nodes容器。函数执行完毕后，副本被销毁，原始数据完全没有被修改，相当于 “白执行”。 2. 树结构构建逻辑错误，无法保留结果 1 2 3 4 5 6 7 8 9 10 11 12 13 void Node::BuildTree(std::vector\u0026lt;Node\u0026gt; nodes) { std::map\u0026lt;std::string, Node\u0026gt; map; // 存储Node的副本 for (auto node: nodes) { map.insert(std::pair\u0026lt;std::string, Node\u0026gt;(node.id, node)); // 复制node到map } for (auto node: map) { auto parent = map.find(node.second.pid); if (parent != map.end()) { // 向parent的children添加node的副本 parent-\u0026gt;second.children.push_back(node.second); } } } 问题 1：map中存储的是Node的副本（而非原始节点的引用或指针），后续对map中节点的修改（如添加子节点）仅作用于这些副本。 问题 2：map是函数内部的局部变量，函数执行结束后会被销毁，其中构建的树结构也会随之消失，无法传递到外部使用。 问题 3：children中存储的也是Node的副本，而非原始节点的关联，导致树结构的节点之间没有实际的引用关系，只是一堆独立的副本。 3. 类封装性缺失，数据安全性差 1 2 3 4 5 6 7 8 class Node { public: std::string id; std::string value; std::string pid; std::vector\u0026lt;Node\u0026gt; children; // ... }; 问题：Node的所有成员变量都被声明为public，外部可以直接修改id、pid等关键数据，可能导致树结构的逻辑被破坏（例如随意修改pid导致父子关系混乱）。良好的设计应将成员变量设为private，通过public的接口（如getter/setter）控制访问和修改。 4. 函数无返回值，无法获取构建结果 问题：BuildTree是void类型，既没有返回构建好的树结构（如根节点），也没有通过引用 / 指针修改外部数据，导致调用者（如main函数）无法获取构建后的树。调用Node::BuildTree(nodes)后，完全无法使用构建的结果。 5. 容器使用效率低，存在冗余操作 map.insert(std::pair\u0026lt;std::string, Node\u0026gt;(node.id, node))可以简化为map[node.id] = node，更简洁。 遍历nodes插入map时，使用auto\u0026amp; node : nodes（引用）可避免一次不必要的复制（当前代码中auto node会复制元素）。 改进方向 修改传参方式：使用const std::vector\u0026lt;Node\u0026gt;\u0026amp; nodes（const 引用）避免复制，若需要修改原始节点，可传递非 const 引用。 使用指针 / 引用关联节点：通过std::vector\u0026lt;Node*\u0026gt;或智能指针存储节点，避免副本，确保树结构的节点关联有效。 增强封装性：将Node的成员变量设为private，提供必要的接口函数。 返回构建结果：让BuildTree返回根节点指针或整个树的结构，方便外部使用。 添加错误处理：对无效的pid（如不存在的父节点 ID）进行处理，避免逻辑错误。 例如，修改后的核心逻辑可能如下（简化示例）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Node { private: // 封装成员变量 std::string id; std::string value; std::string pid; std::vector\u0026lt;Node*\u0026gt; children; // 存储指针，关联原始节点 public: // 构造函数和接口函数 Node(std::string id, std::string value, std::string pid) : id(std::move(id)), value(std::move(value)), pid(std::move(pid)) {} const std::string\u0026amp; getID() const { return id; } const std::string\u0026amp; getPID() const { return pid; } void addChild(Node* child) { children.push_back(child); } // 返回根节点 static Node* BuildTree(std::vector\u0026lt;Node\u0026gt;\u0026amp; nodes) { // 传引用，修改原始数据 std::map\u0026lt;std::string, Node*\u0026gt; nodeMap; // 存储指针，避免复制 for (auto\u0026amp; node : nodes) { // 引用遍历，避免复制 nodeMap[node.getID()] = \u0026amp;node; } Node* root = nullptr; for (auto\u0026amp; node : nodes) { auto parentIt = nodeMap.find(node.getPID()); if (parentIt != nodeMap.end()) { parentIt-\u0026gt;second-\u0026gt;addChild(\u0026amp;node); } else { root = \u0026amp;node; // 假设空pid为根节点 } } return root; // 返回根节点 } }; 考虑到平整结构的集合返回的可能是多个根节点，所以我再次询问AI修改实现，这次将考虑将BuildTree方法返回一个vector\u0026lt;Node*\u0026gt;集合。\n是否要考虑 BuildTree 返回多个根节点？ 需要考虑！实际场景中可能存在多个根节点（即 “森林” 结构），因此 BuildTree 应返回根节点的集合。\n为什么可能存在多个根节点？ 根节点的定义是 “没有父节点的节点”（通常 pid 为空字符串或无效值）。在实际数据中，可能存在多个 pid 为空的节点，例如：\n1 2 3 4 // 示例：两个根节点（pid为空） nodes.push_back(Node(\u0026#34;1\u0026#34;, \u0026#34;根节点1\u0026#34;, \u0026#34;\u0026#34;)); nodes.push_back(Node(\u0026#34;2\u0026#34;, \u0026#34;根节点2\u0026#34;, \u0026#34;\u0026#34;)); nodes.push_back(Node(\u0026#34;3\u0026#34;, \u0026#34;子节点\u0026#34;, \u0026#34;1\u0026#34;)); 此时树结构实际是 “森林”（多棵树的集合），若 BuildTree 仅返回单个根节点，会丢失其他根节点及其子树。\n如何处理多个根节点？ 应将 BuildTree 的返回类型改为根节点指针的集合（如 std::vector\u0026lt;Node*\u0026gt;），遍历所有节点时，将所有无父节点（pid 无效）的节点加入根节点集合。示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static std::vector\u0026lt;Node*\u0026gt; BuildTree(std::vector\u0026lt;Node\u0026gt;\u0026amp; nodes) { std::map\u0026lt;std::string, Node*\u0026gt; nodeMap; for (auto\u0026amp; node : nodes) { nodeMap[node.getID()] = \u0026amp;node; // 存储节点指针 } std::vector\u0026lt;Node*\u0026gt; roots; // 根节点集合 for (auto\u0026amp; node : nodes) { const std::string\u0026amp; pid = node.getPID(); if (pid.empty()) { // pid为空，视为根节点 roots.push_back(\u0026amp;node); } else { auto parentIt = nodeMap.find(pid); if (parentIt != nodeMap.end()) { parentIt-\u0026gt;second-\u0026gt;addChild(\u0026amp;node); // 关联子节点 } else { // 处理无效pid（父节点不存在），可视为根节点或报错 roots.push_back(\u0026amp;node); } } } return roots; // 返回所有根节点 } 我感觉已经很完美了，但我还是想看看AI自己实现会是什么效果，于是我提问：请不要考虑我之前的实现，如果让你写， 你会怎么将平整的Node结构的集合转成树结构。\n让AI从头设计 AI的思考：\n嗯，用户这次的需求是把一个扁平的 Node 结构集合转换成树结构，而且特别强调了不要考虑他之前的实现。这挺好的，意味着我可以从头设计一个更合理的方案，不受历史代码的束缚。\n首先，我得明确这个问题的核心是什么。扁平结构转树形，关键在于如何根据每个节点的父 ID（pid）找到它的父节点，并建立起正确的父子关系。这通常需要一个查找父节点的高效方式，哈希表（在 C++ 里就是 std::unordered_map）应该是个不错的选择，能做到 O (1) 的查找复杂度。\n那么，Node 这个类应该怎么设计呢？它需要有 id、value、pid 这些基本属性，还有一个存储子节点的容器。考虑到效率和避免不必要的复制，子节点容器应该存储指针而不是对象本身。所以，children 应该是std::vector\u0026lt;Node*\u0026gt;类型。成员变量最好设为 private，通过 public 的 getter 和 setter 来访问，这样更符合封装的原则。\n接下来是转换函数，就叫 buildTree 吧。它的输入应该是一个扁平的 Node 集合，为了避免复制，应该用引用传递。返回值呢？考虑到可能存在多个根节点（即 pid 为空或者找不到对应父节点的节点），所以应该返回一个根节点指针的 vector，也就是std::vector\u0026lt;Node*\u0026gt;。\n函数内部的步骤大概是这样的：\n先创建一个哈希表，把每个节点的 id 和它的指针对应起来，方便后续查找父节点。 遍历所有节点，对于每个节点： a. 如果 pid 为空，说明它是一个根节点，加入根节点列表。 b. 如果 pid 不为空，就到哈希表里查找对应的父节点。 c. 如果找到了父节点，就把当前节点添加到父节点的 children 里。 d. 如果没找到父节点，那这个节点也算是一个根节点（可能是数据有问题，但程序应该能处理这种情况），加入根节点列表。 哦，对了，还得考虑内存管理的问题。如果这些 Node 对象是在堆上创建的，那谁来负责释放呢？或许可以提供一个销毁树的函数，递归地删除所有节点。不过，如果 Node 对象是存储在一个容器里，由容器管理生命周期，那可能就不需要这个销毁函数了。这点可以在代码注释里说明一下。\n另外，为了方便测试，我还应该写一个简单的打印树结构的函数，用递归的方式遍历树，打印出每个节点的信息和它的子节点，这样能直观地看到转换结果是否正确。\n最后，在 main 函数里，创建一些测试节点，调用 buildTree 函数，然后打印出结果，再根据情况销毁树（如果需要的话）。\n这样一来，整个方案应该就比较完整了。它既考虑了效率，也考虑了代码的健壮性和可维护性，还能处理多种情况，包括多个根节点的情况。嗯，就按照这个思路来写代码吧。\n我会设计一个更健壮、高效的实现，考虑指针管理、多根节点支持和清晰的接口设计。以下是实现方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory\u0026gt; // 节点类设计，使用封装和智能指针 class Node { private: std::string id; std::string value; std::string pid; std::vector\u0026lt;Node*\u0026gt; children; // 存储子节点指针 public: // 构造函数 Node(std::string id, std::string value, std::string pid) : id(std::move(id)), value(std::move(value)), pid(std::move(pid)) {} // 禁止拷贝构造和赋值（避免指针混乱） Node(const Node\u0026amp;) = delete; Node\u0026amp; operator=(const Node\u0026amp;) = delete; // 允许移动构造和赋值 Node(Node\u0026amp;\u0026amp;) = default; Node\u0026amp; operator=(Node\u0026amp;\u0026amp;) = default; // 接口方法 const std::string\u0026amp; getID() const { return id; } const std::string\u0026amp; getPID() const { return pid; } const std::string\u0026amp; getValue() const { return value; } const std::vector\u0026lt;Node*\u0026gt;\u0026amp; getChildren() const { return children; } // 添加子节点 void addChild(Node* child) { if (child) { children.push_back(child); } } // 递归打印树结构（调试用） void print(int depth = 0) const { // 打印缩进 for (int i = 0; i \u0026lt; depth; ++i) { std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;- \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; // 打印子节点 for (const auto* child : children) { child-\u0026gt;print(depth + 1); } } // 构建树的静态方法，返回根节点集合 static std::vector\u0026lt;Node*\u0026gt; buildTree(std::vector\u0026lt;Node\u0026gt;\u0026amp; nodes) { // 建立ID到节点指针的映射（O(1)查找） std::unordered_map\u0026lt;std::string, Node*\u0026gt; nodeMap; for (auto\u0026amp; node : nodes) { nodeMap[node.getID()] = \u0026amp;node; } std::vector\u0026lt;Node*\u0026gt; roots; // 存储所有根节点 // 构建父子关系 for (auto\u0026amp; node : nodes) { const std::string\u0026amp; parentId = node.getPID(); if (parentId.empty()) { // 没有父节点，作为根节点 roots.push_back(\u0026amp;node); } else { // 查找父节点 auto it = nodeMap.find(parentId); if (it != nodeMap.end()) { // 找到父节点，建立关联 it-\u0026gt;second-\u0026gt;addChild(\u0026amp;node); } else { // 父节点不存在，视为根节点（容错处理） roots.push_back(\u0026amp;node); std::cerr \u0026lt;\u0026lt; \u0026#34;Warning: Parent ID \u0026#39;\u0026#34; \u0026lt;\u0026lt; parentId \u0026lt;\u0026lt; \u0026#34;\u0026#39; not found for node \u0026#39;\u0026#34; \u0026lt;\u0026lt; node.getID() \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; std::endl; } } } return roots; } }; int main() { // 创建扁平节点集合 std::vector\u0026lt;Node\u0026gt; nodes; nodes.emplace_back(\u0026#34;1\u0026#34;, \u0026#34;Root 1\u0026#34;, \u0026#34;\u0026#34;); // 根节点1 nodes.emplace_back(\u0026#34;2\u0026#34;, \u0026#34;Root 2\u0026#34;, \u0026#34;\u0026#34;); // 根节点2（多根节点示例） nodes.emplace_back(\u0026#34;3\u0026#34;, \u0026#34;Child of 1\u0026#34;, \u0026#34;1\u0026#34;); // 节点1的子节点 nodes.emplace_back(\u0026#34;4\u0026#34;, \u0026#34;Child of 3\u0026#34;, \u0026#34;3\u0026#34;); // 节点3的子节点 nodes.emplace_back(\u0026#34;5\u0026#34;, \u0026#34;Child of 2\u0026#34;, \u0026#34;2\u0026#34;); // 节点2的子节点 nodes.emplace_back(\u0026#34;6\u0026#34;, \u0026#34;Orphan Node\u0026#34;, \u0026#34;99\u0026#34;);// 父节点不存在（容错示例） // 构建树 std::vector\u0026lt;Node*\u0026gt; roots = Node::buildTree(nodes); // 打印所有树 std::cout \u0026lt;\u0026lt; \u0026#34;Built \u0026#34; \u0026lt;\u0026lt; roots.size() \u0026lt;\u0026lt; \u0026#34; tree(s):\u0026#34; \u0026lt;\u0026lt; std::endl; for (size_t i = 0; i \u0026lt; roots.size(); ++i) { std::cout \u0026lt;\u0026lt; \u0026#34;Tree \u0026#34; \u0026lt;\u0026lt; (i + 1) \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; std::endl; roots[i]-\u0026gt;print(); } return 0; } 输出结果：\n1 2 3 4 5 6 7 8 9 10 11 Warning: Parent ID \u0026#39;99\u0026#39; not found for node \u0026#39;6\u0026#39; Built 3 tree(s): Tree 1: - 1: Root 1 - 3: Child of 1 - 4: Child of 3 Tree 2: - 2: Root 2 - 5: Child of 2 Tree 3: - 6: Orphan Node 扁平Node集合转树结构的实现\n设计亮点说明 高效的节点查找： 使用unordered_map存储 ID 到节点指针的映射，将父节点查找复杂度从 O (n) 降至 O (1)，大幅提升大数据量下的性能。 支持多根节点： 通过返回vector\u0026lt;Node*\u0026gt;存储所有根节点，自然支持森林（多棵树）结构，符合实际业务场景。 内存安全设计： 禁止拷贝构造和赋值，避免指针混乱 使用原始指针但保证节点存储在容器中，生命周期可控 如需动态管理可改为shared_ptr实现 健壮的容错处理： 对不存在的父节点 ID 进行警告，并将其视为根节点，避免程序崩溃。 清晰的封装接口： 成员变量私有化，通过getter方法访问 提供addChild方法安全添加子节点 内置print方法方便调试查看树结构 无数据复制开销： 全程使用指针操作，避免节点对象的冗余复制，尤其适合处理大量节点的场景。 这个实现既考虑了性能和安全性，又保持了代码的可读性和可维护性，能够适应大多数从扁平结构构建树形结构的需求。\n","date":"2025-08-25T08:22:18+08:00","permalink":"https://bigbosscyb.github.io/p/c-%E5%B9%B3%E6%95%B4%E7%BB%93%E6%9E%84%E8%BD%AC%E6%A0%91%E7%BB%93%E6%9E%84/","title":"C++ 平整结构转树结构"},{"content":"数组 一群同类型元素组成的集合 在内存中连续排列 可以使用下标访问数组中的元素 为什么要有数组，假如我需要1000个整数变量，难道需要一个变量一个变量创建么？引进数组来解决这个问题。\n一维数组创建 一维数组的格式 类型名 数组变量名[元素个数]\n1 2 3 int int_arr[4]; // const int pp = 4; // int intarr[pp];//这种版本高的话(c99以后)才支持 一维数组初始化 数组初始化：在创建数组时给数组赋值\n完全初始化 标准的初始化形式，即使用和声明数组时指定的个数一致的元素给数组初始化\n1 2 char input[3] = {\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;}; // char input2[3]={\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;d\u0026#39;};//初始化时个数可以短 但不可以长 初始化时，元素个数不能比数组长度长；否则编译报错。\n不完全初始化 初始化时，元素个数比数组的长度短\n1 char input4[10] = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}; //不完全初始化 其余未被初始化的位置会被初始化成默认值 数组元素的值的情况：\n前几个元素被正常赋值；后几个元素被系统初始化成该类型的默认值；\n可以利用不完全初始化这一特点，将数组元素全部初始化成默认值，如char类型元素组成的数组，初始化成全0\n1 char input5[10] = {0}; //通过此特性，将数组初始化成全0 不指定数组大小 当数组创建时不指定长度，则初始化时给定多少个元素，那么数组的长度就是多长。\n1 char input3[] = {\u0026#39;a\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;i\u0026#39;}; 字符数组与字符串 下面这两种形式数组的区别：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { char input3[] = {\u0026#39;a\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;i\u0026#39;}; //不指定数组大小的初始化 char str[] = \u0026#34;ali\u0026#34;;//使用字符串字面量初始化字符数组 //它与input3有什么区别? //空间不同：字符串自带一个\\0字符；所以str在空间占用上比input3大 //strlen函数求字符串长度结果不同：因为strlen函数遇到str数组中的\\0字符会结束 然后返回除\\0外还有多少个字符 //而strlen处理字符数组input3时，什么时候遇到\\0字符是未知的，所以得到的结果是随机的 size_t size_str = sizeof(str); size_t size_input3 = sizeof(input3); printf(\u0026#34;str size is:%d,input3 size is:%d \\n\u0026#34;, size_str, size_input3); size_t len_str = strlen(str); size_t len_input3 = strlen(input3); printf(\u0026#34;str strlen is:%d,input3 str len is:%d \\n\u0026#34;, len_str, len_input3); return 0; } 输出：\n1 2 str size is:4,input3 size is:3 str strlen is:3,input3 str len is:9 //input3由于没有字符串结束符\\0，所以strlen结果是随机的 所占据的空间不同，使用sizeof操作符，求两个数组的大小，显然后者的长度要大 strlen函数求字符串长度，结果不同：strlen函数从第一个字符开始，看到str数组中的\\0字符返回，除\\0外共多少个字符个数，就是字符串的长度；对于字符数组input3来说，由于其中并没有包含\\0字符，所以其结果是随机的未知的 后来有人告诉我们，strlen这样理解：就好比你朗读课文时句号你不会读出来一样。在计算字符串长度时strlen只把\\0当标记，不会把它统计入长度的\n一维数组的使用 按索引访问元素：数组名[索引值] 就可以访问到数组中的指定位置的元素 数组元素个数计算：用sizeof求数组总共占用的空间、用sizeof(arr[0])求数组中一个元素占用的空间、最后用总空间除以单个元素的空间得到数组元素个数。 如何修改数组中某个位置的元素的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 char input[3] = {\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;}; size_t size = sizeof(input); //sizeof可以计算出数组所占空间大小 size_t size_item = sizeof(input[0]); //计算数组中第一个元素所占空间大小 size_t count = size / size_item; printf(\u0026#34;数组修改前：\\n\u0026#34;); for (size_t i = 0; i \u0026lt; count; i++) { printf(\u0026#34;index of %d,value is %c \\n\u0026#34;, i, input[i]); char item = input[i]; item = \u0026#39;\\0\u0026#39;; } printf(\u0026#34;数组修改后：\\n\u0026#34;); for (size_t i = 0; i \u0026lt; count; i++) { printf(\u0026#34;index of %d,value is %c \\n\u0026#34;, i, input[i]); } 输出：\n1 2 3 4 5 6 7 8 数组修改前： index of 0,value is a index of 1,value is c index of 2,value is e 数组修改后： index of 0,value is a index of 1,value is c index of 2,value is e 可以看出上面的修改数组的方式是错误❌的；item在初始化后便和数组元素没有关系了(下图从内存地址可以看出)；所以修改item并不会对数组中的元素造成任何影响。\n所以正确的修改数组元素的方式应该是：要么使用指针，要么直接使用下标进行修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 char input[3] = {\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;}; size_t size = sizeof(input); //sizeof可以计算出数组所占空间大小 size_t size_item = sizeof(input[0]); //计算数组中第一个元素所占空间大小 size_t count = size / size_item; printf(\u0026#34;数组修改前：\\n\u0026#34;); for (size_t i = 0; i \u0026lt; count; i++) { printf(\u0026#34;index of %d,value is %c \\n\u0026#34;, i, input[i]); } printf(\u0026#34;请输入三个字符串，输入完成后按下回车键确认\\n\u0026#34;); for (size_t i = 0; i \u0026lt; count; i++) { scanf(\u0026#34;%c\u0026#34;, \u0026amp;input[i]); } printf(\u0026#34;数组修改后：\\n\u0026#34;); for (size_t i = 0; i \u0026lt; count; i++) { printf(\u0026#34;index of %d,value is %c \\n\u0026#34;, i, input[i]); } 输出\n1 2 3 4 5 6 7 8 9 10 数组修改前： index of 0,value is a index of 1,value is c index of 2,value is e 请输入三个字符串，输入完成后按下回车键确认 hhh 数组修改后： index of 0,value is h index of 1,value is h index of 2,value is h 使数组不可被修改 在数组声明时，前面加上const，那么数组中的每一个元素就变成了只读量，只能访问不能修改。\n1 2 const int intarr[3] = {\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;}; intarr[0] = 1; 编译错误：\n1 2 3 /Users/a77/Code/clangbasedemo/main.c:6:15: error: cannot assign to variable \u0026#39;intarr\u0026#39; with const-qualified type \u0026#39;const int[3]\u0026#39; intarr[0] = 1; ~~~~~~~~~ ^ 由此，我们联想到 在一个函数中，若不希望形参被修改，可以给形参加上const修饰，起到保护形参的作用。\n一维数组在内存中的存储 1 2 3 4 5 6 7 int intarr[3] = {\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;}; size_t size = sizeof(intarr); //sizeof可以计算出数组所占空间大小 size_t size_item = sizeof(intarr[0]); //计算数组中第一个元素所占空间大小 size_t count = size / size_item; for (size_t i = 0; i \u0026lt; count; i++) { printf(\u0026#34;index of %d,address is %p \\n\u0026#34;, i, \u0026amp;intarr[i]); } 输出\n1 2 3 index of 0,address is 0x16d8534b8 index of 1,address is 0x16d8534bc index of 2,address is 0x16d8534c0 a0和a1相差4；为什么？因为一个int值在内存中占4个字节。（回忆旧知识：内存中最小单位是字节，故地址与地址之间差值最小是1字节）\n数组越界访问 什么是越界访问：下标是不在数组元素范围内。如：\n1 int arr[3]={1,2,3}; int item= arr[99]; 数组越界访问，编译器是允许的；因为编译器足够信任程序员，认为程序员不会做出越界访问这种事情。另外不进行这种检查，还可以提高运行效率。\n二维数组 比一维数组多了一个[]；\n1 2 //格式 类型名 数组名[m][n] char list[3][4]; 从左往右 list先与[3]结合，所以list是一个由三个元素组成的数组；然后去掉list[3]剩下的就是元素类型；可以看到组成list[3]的每个元素都是一个数组。这个数组长度是4。\n还可以将二维数组看成3行4列的网格\n二维数组初始化 完全初始化 3*4=12，所以共需要12个数来初始化二维数组。\n1 char list[3][4] = {\u0026#39;h\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;g\u0026#39;}; 来看数组的情况：\n不完全初始化 和一维数组一样，只要我们给定的元素个数不足以填充数组长度；那么这种初始化方式就称为不完全初始化\n1 char list1[3][4] = {\u0026#39;h\u0026#39;, \u0026#39;u\u0026#39;}; 看数组内元素的情况：\n与一维数组处理一致，未赋值的元素，会被默认初始化成该元素类型的默认值；\n使用一维数组初始化 二维数组中，是由几个一维数组组成；所以在此例中使用三个长度为4的一维数组，即可完成初始化\n1 char list2[3][4] = {{\u0026#39;h\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;o\u0026#39;}, {\u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;e\u0026#39;}, {\u0026#39;p\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;g\u0026#39;}}; 也可以这样\n1 char list3[3][4] = {{\u0026#39;h\u0026#39;}, {\u0026#39;l\u0026#39;}}; 二维数组在内存中的分布 1 2 3 4 5 6 7 8 char list[3][4] = {\u0026#39;h\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;g\u0026#39;}; size_t row_size = sizeof(list) / sizeof(list[0]); size_t col_size = sizeof(list[0]) / sizeof(list[0][0]); for (size_t i = 0; i \u0026lt; row_size; i++) { for (size_t j = 0; j \u0026lt; col_size; j++) { printf(\u0026#34;position is :(%d,%d),value is %c,address is %p\\n\u0026#34;, i, j, list[i][j], \u0026amp;list[i][j]); } } 输出\n1 2 3 4 5 6 7 8 9 10 11 12 position is :(0,0),value is h,address is 0x16f2234b8 position is :(0,1),value is u,address is 0x16f2234b9 position is :(0,2),value is g,address is 0x16f2234ba position is :(0,3),value is o,address is 0x16f2234bb position is :(1,0),value is l,address is 0x16f2234bc position is :(1,1),value is o,address is 0x16f2234bd position is :(1,2),value is v,address is 0x16f2234be position is :(1,3),value is e,address is 0x16f2234bf position is :(2,0),value is p,address is 0x16f2234c0 position is :(2,1),value is i,address is 0x16f2234c1 position is :(2,2),value is n,address is 0x16f2234c2 position is :(2,3),value is g,address is 0x16f2234c3 可以看到地址是连续的，所以无论是几维数组，在内存中元素都是连续存储的。数组的维度只是我们逻辑上的，计算机上一直线性顺序存储。\n","date":"2025-08-17T07:56:19+08:00","permalink":"https://bigbosscyb.github.io/p/c%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84/","title":"c语言 数组"},{"content":"在我们学习c语言之初，第一个接触的函数就是：\nprintf函数，他是一个库函数。如果c语言不提供给我们这个库函数，我们就得自己实现。\n库函数 我们就把：c语言内置的一系列函数，成为库函数。在这个网站可以查询并学习：C Library\n自定义函数 库函数不是万能的，他能够解决一些通用场景的编程工作；但是有些时候为完成特定目标的工作，则需要自己编写函数进行实现。\n函数的格式 函数返回值类型 函数名 (函数参数类型 函数参数的变量名)\n{\n​\t//函数功能实现部分 一般由一些语句组成\n}\n请注意，花括号也属于函数的一部分；在花括号中进行功能实现。\n函数的声明与定义 函数声明：告诉编译器，有这么一个函数：函数名是什么、返回值类型是什么、参数是什么。仅此而已，但是否真的存在这个函数，仅仅有函数声明是决定不了的。\n函数调用：函数声明一定写在要在函数调用之前，否则编译器会提示找不到这个函数。\n函数定义：函数的具体功能实现的过程，就是函数定义。\n下面以一个add函数的声明、定义、调用来了解上面这些话：\n调用未声明的函数 1 2 3 4 5 int a = 1; int ret = Add(a, a); printf(\u0026#34;%d + %d = %d \\n\u0026#34;, a, a, ret); //编译出错：error: call to undeclared function \u0026#39;Add\u0026#39;; --意思是：调用了未声明的函数 仅进行函数声明，未进行函数实现 1 2 3 4 5 6 7 8 9 10 int Add(int x, int y); int main(void) { int a = 1; int ret = Add(a, a); printf(\u0026#34;%d + %d = %d \\n\u0026#34;, a, a, ret); return 0; } //编译出错：Undefined symbols for \u0026#34;_Add\u0026#34;... --意思是：符号Add，未定义 函数的定义在调用函数之后 1 2 3 4 5 6 7 8 9 10 11 12 int main(void) { int a = 1; int ret = Add(a, a); printf(\u0026#34;%d + %d = %d \\n\u0026#34;, a, a, ret); return 0; } int Add(int x, int y) { return x + y; }; //编译出错：error: call to undeclared function \u0026#39;Add\u0026#39;; --意思是：调用了未声明的函数 上面演示了一些未遵循函数声明、定义、调用规定的错误情形，下面提供一个无错误的版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int Add(int x, int y); int main(void) { int a = 1; int ret = Add(a, a); printf(\u0026#34;%d + %d = %d \\n\u0026#34;, a, a, ret); return 0; } int Add(int x, int y) { return x + y; }; //输出：1 + 1 = 2 函数调用时的传参 函数的形参是实参值的拷贝，改变形参的值不会对实参产生任何影响。\n举个例子，编写一个函数Swap(int x,int y)，目的是：调用Swap函数，实现两个数的值的交换。\n我们很容易写出如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; void Swap(int x, int y); int main(void) { int a = 1; int b = 2; printf(\u0026#34;a is :%d ;b is: %d \\n\u0026#34;, a, b); Swap(a, b); printf(\u0026#34;after swap ,a is :%d ;b is: %d \\n\u0026#34;, a, b); return 0; } void Swap(int x, int y) { printf(\u0026#34;in swap function begin,x is :%d ;y is: %d \\n\u0026#34;, x, y); int temp = x; x = y; y = temp; printf(\u0026#34;in swap function end,x is :%d ;y is: %d \\n\u0026#34;, x, y); } 程序输出\n1 2 3 4 5 6 7 a is :1 ;b is: 2 in swap function begin,x is :1 ;y is: 2 in swap function end,x is :2 ;y is: 1 a is :1 ;b is: 2 in swap function begin,x is :1 ;y is: 2 in swap function end,x is :2 ;y is: 1 after swap ,a is :1 ;b is: 2 为什么a、b没有发生交换？因为形参x,y的值是从实参a，b的复制而来的，x，y有值后就和a，b没有关系了；\n可以认为这里隐藏了一个赋值操作，即：\n1 int x =a; int y=b; //如果这样写，更容易弄清 x 与 a；y 与 b的关系了吧？对，他俩没关系。 函数参数的传递 函数的参数值传递本质就只有一种：那就是值传递。 地址传递，引用传递其实都是值传递。只不过因为根据他们带来的一些效果，人们特别这样称呼他们而已； 就比如：打篮球，不管你做出什么动作最终效果就是进球。有人将跳起来直接将篮球灌入篮框这一酷炫动作特称为：灌篮！ 我们可以通过断点调试的方式，来了解一下函数参数的值传递：\n请注意，每次调试时变量的地址都有可能不同，我的电脑中变量的地址和你的电脑中变量的地址也几乎不会相同；当你调试时不要对这些差异感到焦虑。\n在调用Swap函数前打上断点，观察到a、b的地址是：\na的地址 0x000000016b66b4c8\nb的地址 0x000000016b66b4c0\n进入到Swap函数中，观察到x、y的地址是：\nx的地址 0x000000016b66b49c\ny的地址 0x000000016b66b498\n可以看到a、b的地址和x、y的地址不相同，那操作x、y影响的也只是x、y所在内存处的内容；与a、b没有任何关系了。\n那么有什么办法，能实现调用Swap后交换a、b的值？方法不止一种，这里介绍一种：\n函数参数传递方式之：地址传递 将a、b的地址传递给x、y；通过*x和*y 操作指定地址上的内存，就等于在操作函数外部的a、b。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; void Swap(int *x, int *y); int main(void) { int a = 1; int b = 2; printf(\u0026#34;a is :%d ;b is: %d \\n\u0026#34;, a, b); Swap(\u0026amp;a, \u0026amp;b); printf(\u0026#34;after swap ,a is :%d ;b is: %d \\n\u0026#34;, a, b); return 0; } void Swap(int *x, int *y) { printf(\u0026#34;in swap function begin,*x is :%d ;*y is: %d \\n\u0026#34;, *x, *y); int temp = *x; *x = *y; *y = temp; printf(\u0026#34;in swap function end,*x is :%d ;*y is: %d \\n\u0026#34;, *x, *y); } 观察a的地址 0x000000016cfcb4c8\n观察b的地址 0x000000016cfcb4c4\nx存储的值是 0x000000016cfcb4c8 这个地址指向的就是变量a；y存储的值是 0x000000016cfcb4c4 这个地址指向的就是变量b。\n最后程序输出：\n1 2 3 4 a is :1 ;b is: 2 in swap function begin,*x is :1 ;*y is: 2 in swap function end,*x is :2 ;*y is: 1 after swap ,a is :2 ;b is: 1 如此一来，我们通过*x和*y进行交换变量的操作，就是对a、b本身进行的操作。\n总结：\n函数的形参是实参值的拷贝、改变形参不会对实参产生影响； 在函数内想要操作函数外的变量，可以将外部变量的地址传递进来。 思考：形参是实参值的拷贝，改变形参不会对实参产生影响；那上面例子中通过*x=*y;*y=temp;最终改变了外部变量a、b的值，不就和前面的“不会对实参产生影响”自相矛盾了么？\n我的理解：并没有冲突，因为a、b并不是实参，而\u0026amp;a，\u0026amp;b才是实参\n可以通过下面例子印证：形参的改变，不会影响实参\u0026ndash;因为函数调用前后实参\u0026amp;a和\u0026amp;b的值没有变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; void Swap(int *x, int *y); int main(void) { int a = 1; int b = 2; printf(\u0026#34;a address is :%p ;b address is: %p \\n\u0026#34;, \u0026amp;a, \u0026amp;b); Swap(\u0026amp;a, \u0026amp;b); printf(\u0026#34;a address is :%p ;b address is: %p \\n\u0026#34;, \u0026amp;a, \u0026amp;b); return 0; } //现在函数内部 将x与y的值进行交换 这样x、y的值改变 并不会影响实参 \u0026amp;a 和 \u0026amp;b的值 void Swap(int *x, int *y) { printf(\u0026#34;in swap function begin,x is :%d ;y is: %d \\n\u0026#34;, *x, *y); int *temp = x; x = y; y = temp; printf(\u0026#34;in swap function end,x is :%d ;y is: %d \\n\u0026#34;, *x, *y); } 输出：\n1 2 3 4 a address is :0x16f9374c8 ;b address is: 0x16f9374c4 in swap function begin,x is :1 ;y is: 2 in swap function end,x is :2 ;y is: 1 a address is :0x16f9374c8 ;b address is: 0x16f9374c4 ","date":"2025-08-10T16:18:51+08:00","permalink":"https://bigbosscyb.github.io/p/c%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0/","title":"c语言 函数"},{"content":"计算机中浮点数的存储方式 在计算机中浮点数采用科学记数法\nfloat 4个字节 32位 从高到低依次是：\n31 30-23 22-0 符号位 0或1 指数位8位 小数部分23位 举例：十进制的小数20.1如何转成计算机中的存储形式（二进制）呢？\n步骤：\n整数部分和小数部分分别转成二进制 整数部分转二进制：除2取余，拿整数部分除2，每次操作记下余数，然后拿商继续除2，直到商为0；最后将每一步求得的余数倒叙排列。 小数部分转二进制：乘2取整，拿小数部分即0.xxx乘2，每次操作结果留整数部分，接下来继续拿小数部分乘2，直到小数部分为0；最后将每步求得的整数部分正序排列。 移位成标准的科学记数法，即： $$ a*10^b (1\u003c=a\u003c=10) $$ 让指数+127 取小数部分位前23位，不足23位后面补0，超过23位只取前23位 实战：\n分别将整数和小数部分转成二进制 对于20转二进制：\n20/2\t商10\t余0 10/2 商5 余0 5/2 商2 余1 2/2 商1 余0 1/2 商0 余1 🔚 所以二进制存储形式：10100\n对于0.1转二进制\n0.1*2\t得0.2\t整数部分0\t接下来拿小数部分0.2继续乘2 0.2*2\t得0.4\t整数部分0\t接下来拿小数部分0.4继续乘2 0.4*2\t得0.8\t整数部分0\t接下来拿小数部分0.8继续乘2 0.8*2\t得1.6\t整数部分1\t接下来拿小数部分0.6继续乘2 0.6*2\t得1.2\t整数部分1\t接下来拿小数部分0.2继续乘2 0.2*2\t得0.4\t整数部分0\t接下来拿小数部分0.4继续乘2 0.4*2\t得0.8\t整数部分0\t接下来拿小数部分0.8继续乘2 0.8*2\t得1.6\t整数部分1\t接下来拿小数部分0.6继续乘2 0.6*2\t得1.2\t整数部分1\t接下来拿小数部分0.2继续乘2 0.2*2\t得0.4\t整数部分0\t接下来拿小数部分0.4继续乘2 0.4*2\t得0.8\t整数部分0\t接下来拿小数部分0.8继续乘2 0.8*2\t得1.6\t整数部分1\t接下来拿小数部分0.6继续乘2 0.6*2\t得1.2\t整数部分1\t接下来拿小数部分0.2继续乘2 0.2*2\t得0.4\t整数部分0\t接下来拿小数部分0.4继续乘2 0.4*2\t得0.8\t整数部分0\t接下来拿小数部分0.8继续乘2 0.8*2\t得1.6\t整数部分1\t接下来拿小数部分0.6继续乘2 0.6*2\t得1.2\t整数部分1\t接下来拿小数部分0.2继续乘2 0.2*2\t得0.4\t整数部分0\t接下来拿小数部分0.4继续乘2 0.4*2\t得0.8\t整数部分0\t接下来拿小数部分0.8继续乘2 0.8*2\t得1.6\t整数部分1\t接下来拿小数部分0.6继续乘2 0.6*2\t得1.2\t整数部分1\t接下来拿小数部分0.2继续乘2 0.2*2\t得0.4\t整数部分0\t接下来拿小数部分0.4继续乘2 0.4*2\t得0.8\t整数部分0\t接下来拿小数部分0.8继续乘2 0.8*2\t得1.6\t整数部分1\t接下来拿小数部分0.6继续乘2 0.6*2\t得1.2\t整数部分1\t接下来拿小数部分0.2继续乘2 可以看到已经开始无限循环了 下面的计算省略 所以0.1转成二进制，是一个无限循环小数，即：00011001100110011001100\u0026hellip;..\n移位成标准记数法 即：10100. 00011001100110011001100110011\u0026hellip;. * 2^0\n变成：1. 0100 00011001100110011001100110011\u0026hellip;*2^4\n指数部分处理 4+127=131 ,131转二进制，10000011\n小数部分取前23位，不够的末尾补0，超出的截断\u0026ndash;这也就是浮点数存在误差的由来\n01000001100110011001101（最后这个1是四舍五入来的）\n整合最后结果 0（符号位）10000011（指数位）01000001100110011001101（小数位） 0 10000011 01000001100110011001101\n转换成16进制：\n转换为十六进制（每 4 位一组）： 0100 0001 1010 0000 1100 1100 1100 1101 → 0x41A0CCCD\n在编译器中验证 由于是小端存储，所以我们的计算结果其实是对的上的。关于大小端可以看我的这篇博客：C 大端存储与小端存储\n参考： 在线进制转换工具\n0.5转换成二进制\n十进制小数转化为二进制小数\n浮点数的十进制和二进制转换（详细例子解答）\n","date":"2025-08-09T10:13:43+08:00","permalink":"https://bigbosscyb.github.io/p/c%E8%AF%AD%E8%A8%80-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/","title":"c语言 浮点数的存储方式"},{"content":"本篇只记录觉得比较重要的‼️\n操作符 我也经常叫他运算符，常见的有：\n算术操作符，如：+、-、*、/ 加减乘除 逻辑操作符，如：\u0026amp;\u0026amp; || ! 与或非 位移操作符，如：\u0026laquo; 、\u0026raquo; 左移右移 下标操作符，即：[]定位数组的某个元素 成员访问操作符，如：结构体变量.结构体成员、结构体指针-\u0026gt;结构体成员 函数调用操作符，如：func();表示调用func函数 单目操作符，如：++、\u0026ndash;、*间接访问操作符(解引用操作符)、()强制类型转换、\u0026amp;取地址、sizeof获取操作数的类型长度(字节为单位) 三目操作符，即：关系表达式1?语句1:语句2 关系操作符，如：\u0026gt; 、\u0026lt; 、!= 、== 位移运算符 分为左移和右移，左移与我们下意识一致：超出部分丢弃、最右侧补0；但右移有些不同：\n分为算术右移和逻辑右移，默认情况下编译器采用算术右移：\n逻辑位移：向该方向推出指定位数、另一方向补0 算术位移：向该方向推出指定位数、另一方向补符号位的符号 下面通过几行代码了解一下正数和负数的右移\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //在内存中数据都是以二进制补码形式存储 //1的补码 0000 0000 0000 0000 0000 0000 0000 0001 //位移操作 默认采用的是算术位移 即 向右位移右侧丢弃 左侧补符号位 //故1向右位移 （0补入） 000 0000 0000 0000 0000 0000 0000 000 （1丢弃） int a = 1; int b = a \u0026gt;\u0026gt; 1; int c = a \u0026gt;\u0026gt; 2; printf(\u0026#34;1\u0026gt;\u0026gt;1=%d\\n\u0026#34;, b); printf(\u0026#34;1\u0026gt;\u0026gt;2=%d\\n\u0026#34;, c); //-1的补码=int类型的模数-abs(-1) //-1的原码 1000 0000 0000 0000 0000 0000 0000 0001 //-1的反码 1111 1111 1111 1111 1111 1111 1111 1110 //-1的补码 1111 1111 1111 1111 1111 1111 1111 1111 //故1向右位移 （1补入） 111 1111 1111 1111 1111 1111 1111 111 （1丢弃） int x = -1; int y = x \u0026gt;\u0026gt; 1; int z = x \u0026gt;\u0026gt; 2; printf(\u0026#34;-1\u0026gt;\u0026gt;1=%d\\n\u0026#34;, y); printf(\u0026#34;-1\u0026gt;\u0026gt;2=%d\\n\u0026#34;, z); 输出\n1 2 3 4 1\u0026gt;\u0026gt;1=0 1\u0026gt;\u0026gt;2=0 -1\u0026gt;\u0026gt;1=-1 -1\u0026gt;\u0026gt;2=-1 表达式 由运算符和运算对象，组成表达式。单独的一个运算对象也叫表达式，如：4 、-4这也叫表达式；但更常见的形式还是运算符和运算对象组合，如：\n4+4、(double)4、a\u0026gt;4、a=++4\n关系表达式 关系表达式的结果：要么0 要么1。\n警惕陷阱\n1 2 3 int a = 20.1; bool result= 1\u0026lt;a\u0026lt;10; //result的值竟然是 true！ 因为：运算顺序，从左到右，1先和a比较，结果为真，故结果为1；1再和10比较，结果为真。\n在c语言中0表示假，非0表示真(通常为1)\n语句 一条语句相当于一条计算机指令；语句通常以分号结尾，单独的一个分号称作空语句。\n常见的语句形式 表达式+分号\n分支语句 如果 条件成立 则如何如何 ;否则 则如何如何.\n警惕 悬空else\n如下代码：\n1 2 3 4 5 6 7 8 9 10 float a = 20.1; float b = 20.3; if (a==20.3f) if (b==20.1f) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); //什么也不会打印 因为当有嵌套的if else时，else会和最近的if匹配。\n如何解决：给每个if else后加上大括号。\n1 2 3 4 5 6 7 8 9 10 float a = 20.1; float b = 20.3; if (a == 20.3f) { if (b == 20.1f) { printf(\u0026#34;Yes\\n\u0026#34;); } } else { printf(\u0026#34;No\\n\u0026#34;); } 一个建议：在写条件语句时，关系表达式中若有常量参与，建议将常量写在左边，好处是：避免笔误。\n如：\n1 2 3 float a=20.1; if (a=5){printf(\u0026#34;a equal 5.\\n\u0026#34;);} //输出：a equal 5. aha，竟然表达式成立了？为什么？因为表达式结果a是5，非零则为真，所以表达式成立。\n如果这样写：\n1 2 3 float a=20.1; if (5=a){printf(\u0026#34;a equal 5.\\n\u0026#34;);} //编译器会提示错误，提示我们表达式写的有问题。 编译器会提示我们，表达式写的有问题，我们就会发现：原来少写了一个等号。\n","date":"2025-08-06T08:42:20+08:00","permalink":"https://bigbosscyb.github.io/p/c%E8%AF%AD%E8%A8%80-%E8%BF%90%E7%AE%97%E7%AC%A6-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E5%8F%A5/","title":"c语言 运算符 表达式 语句"},{"content":"使用 Cloudflare 的免费的 R2 对象存储搭建图床、然后在 piclist 工具中进行 R2 存储桶实现图片的上传、删除、最后在 md 文档编辑器 typora 中关联 piclist，实现博客中的图片自动上传至图床中。\npiclist 配置 下面是 Piclist 的介绍\n下载配置 下载地址\n由于我使用的是 Cloudflare 的 R2 对象存储做图床，而 R2 走的是 S3 协议，所以这里介绍 Piclist 自带Aws S3插件进行配置,不需要再像 picgo 那样额外下载 s3 插件了跟着链接中的教程输入\naccessKeyID/api 令牌\nsecretAccessKey/api 访问密钥\nbucketName/存储桶名称\nuploadPath/上传路径\nendpoint/自定义终端节点\nurlPrefix/自定义域名\n其余未提及的保持默认即可。\n测试是否成功 使用截图工具截一张图，从到 PicList 的\u0026quot;上传\u0026quot;菜单中，选择从\u0026quot;剪切板上传\u0026quot;\ntypora 配置 在 typora 中打开\u0026quot;格式\u0026quot;-\u0026ldquo;图像\u0026rdquo;-\u0026ldquo;全局图像设置\u0026rdquo;。\n最后，当文章写完之后，可以一键将本地图片上传至图床中。\n以上便 typora 使用图床的相关配置。\n","date":"2025-08-03T08:38:22+08:00","permalink":"https://bigbosscyb.github.io/p/typora%E5%86%99%E5%8D%9A%E5%AE%A2%E6%97%B6%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/","title":"typora写博客时使用自己的图床"},{"content":"整体流程 安装vscode 下载mingw 配置mingw 下载c/c++插件 使用vscode编写c/c++代码 设置编译选项 配置生成任务 启动项配置 VScode的安装 官网：Visual Studio Code - Code Editing. Redefined\n非官方加速站点：\nMingw的安装 官网：[x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z](https://sourceforge.net/projects/mingw-w64/files/Toolchains targetting Win64/Personal Builds/mingw-builds/8.1.0/threads-win32/seh/x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z/download)\n非官方加速站点：mingw64-x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z\n从网上找到了一个文章介绍mingw各个版本的区别\n参考：[【c/cpp 开发工具】MingGW 各版本区别及安装说明](【c/cpp 开发工具】MingGW 各版本区别及安装说明_mingw sjlj seh-CSDN博客)\n配置mingw 解压：上一步下载好的压缩文件 建议直接将解压后的Mingw64文件夹直接剪切到C盘或者其它盘的根目录 设置环境变量：将mingw的bin目录添加到环境变量中 打开cmd窗口，输入gcc \u0026ndash;version 输出类似如下信息，则代表mingw配置完成\nc/c++插件 在Vscode的扩展中搜索c/c++，点击安装即可\n使用vscode编写c/c++代码 本地磁盘创建一个用于存放c/c++代码的目录 使用vscode打开某个代码目录 设置编译选项 Ctrl+Shift+P 打开命令面板\n注意：我这里默认的编译器路径是cl.exe，因为我安装了VS 2022，这个是vs的编译器，我们不使用这个路径！！！\n配置完成后 .vscode文件夹下的配置如下：\n创建执行任务 设置完编译器之后，如何来编译c代码呢？需要创建执行任务，让Vscode知道如何执行编译(构建)任务。\n在顶部\u0026quot;终端\u0026quot;菜单下拉选项中选择，\u0026ldquo;配置任务\u0026rdquo; 在新弹出的菜单中选择gcc编译器，生成配置文件 对tasks.json的解读 编译 想要编译哪个文件就打开哪个文件 在顶部\u0026quot;终端\u0026quot;菜单的下拉选项中选择\u0026quot;运行生成任务\u0026quot; 执行 在顶部\u0026quot;查看\u0026quot;菜单的下拉选项中选择\u0026quot;终端\u0026quot;选项 在下方新打开的终端工具中，输入./test.exe即可运行编译生成的程序 还想写其它代码 在本目录中新增了一个.c文件 例如又新增了一个test2.c文件来跑另外一个demo\n要编译哪个文件就选中这个文件 Ctrl+Shift+B 运行生成任务 在终端工具中 输入./test2.exe即可运行 在一个新的目录中编写代码 如下图新增了一个seconddemo文件夹，来写代码；如何快速完成?\nvscode打开文件夹 将之前文件夹的.vscode文件夹拷贝到这个文件夹下 新建.c文件编写代码 终端\u0026ndash;\u0026gt;执行生成任务 完成编译 总之就是我们不必再从头进行环境配置！！！\n有多个.c文件如何编译 有多个.c文件，在hello.c文件中调用了util.c中的sub函数\n此时进行代码生成，会提示如下错误：\n1 2 3 4 cmd /c chcp 65001\u0026gt;nul \u0026amp;\u0026amp; D:/mingw64/bin/gcc.exe -fdiagnostics-color=always -g E:\\cppdemos\\seconddemo\\hello.c -o E:\\cppdemos\\seconddemo\\hello.exe D:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.5.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\48723\\AppData\\Local\\Temp\\ccGODLI4.o: in function `main\u0026#39;: E:/cppdemos/seconddemo/hello.c:9: undefined reference to `sub\u0026#39; collect2.exe: error: ld returned 1 exit status 我们如何能运行生成任务时，能将所有的C代码都进行编译、最后输出一个文件目.exe的可执行文件?\n答案是：修改tasks.json文件\n改造tasks.json 修改args节点，-g参数：让编译器编译目录下所有的.c文件； [可选]修改args节点，-o参数：让生成的输出文件，文件名是以工作目录文件夹名命名的exe文件； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活动文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;D:/mingw64/bin/gcc.exe\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-fdiagnostics-color=always\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;${workspaceFolder}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${workspaceFolder}\\\\${workspaceFolderBasename}.exe\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;D:/mingw64/bin\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;detail\u0026#34;: \u0026#34;编译器: D:/mingw64/bin/gcc.exe\u0026#34; } ] } 这样就可以正常编译和运行程序了。\n如何编译c++代码 新增一个.cpp结尾的文件 同上面.c文件的配置类似，需要设置编译选项、创建执行任务 配置g++.exe为编译器 配置c++源文件的任务信息 编译c++代码 以上步骤直接放到下面录屏中：\n注意两点：\n配置g++.exe为编译器时，需要添加配置 配置任务时，需要打开.cpp文件后，点击\u0026quot;终端\u0026quot;\u0026ndash;\u0026gt;\u0026ldquo;配置任务\u0026rdquo; 如何调试代码 以上只介绍了，如何编译代码和运行程序；在VsCode中想要调试，需要创建launch.json\n创建launch.json 点击左侧\u0026quot;调试\u0026quot;菜单，点击\u0026quot;创建launch.json文件\u0026quot;，在弹出的菜单中，选择\u0026quot;C++(GBD/LLDB)\u0026quot;\n点击添加配置按钮，在弹出菜单中选择\u0026quot;c/c++ (gdb) 启动\u0026quot;\n修改完成后launch.json内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;(gdb) 启动\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}\\\\${workspaceFolderBasename}.exe\u0026#34;,//这里修改后保持和tasks.json中的-o参数一致 \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;D:\\\\mingw64\\\\bin\\\\gdb.exe\u0026#34;,//这里修改为你的电脑上gdb.exe路径 \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;为 gdb 启用整齐打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true }, { \u0026#34;description\u0026#34;: \u0026#34;将反汇编风格设置为 Intel\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-gdb-set disassembly-flavor intel\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ] } ] } 开始调试 介绍一些快捷键 F5 启动调试 F9 设置断点 Ctrl+Shift+B 编译代码 以上便是VsCode进行C/C++环境配置的全部内容。\n","date":"2025-07-06T23:38:10+08:00","permalink":"https://bigbosscyb.github.io/p/%E4%BD%BF%E7%94%A8vscode%E5%BC%80%E5%8F%91c/c-/","title":"使用vscode开发c/c++"},{"content":"介绍Hugo 基于GO语言编写的静态网站生成器，能够托管在Github Pages上，可以集成git discuss的评论系统，无需数据库，不需要写代码，就可以快速帮助你搭建一个属于自己的博客网站。\n下载Hugo 方式一：从github下载release版 方式二：如果访问github速度太慢，可以在浏览器搜索Hugo下载 总之，下载的是这个压缩包：\n使用Hugo 创建站点 我们主要是在使用hugo.exe来进行一系列操作的，这里建议新开一个要写博客的目录，（由于我们没有把hugo.exe配置到环境变量中）接着把hugo.exe拷贝到那个目录。\n然后使用 hugo new site 命令创建一个博客站点，如下：\n1 hugo new site hugo-test 命令执行成功后，会生成一个hugo-test的目录，那么一个本地博客站点就已经搭建好了。\n可以观察到目录里面的内容\n浏览博客站点 虽然我们还没有写一篇博客，但我们已经可以浏览这个站点了；这里我们还是把hugo.exe往hugo-test目录下拷贝，以便于能继续使用hugo命令\n1 hugo server -D #-D中的D是buildDrafts的简写 键盘按住CTRL键，然后鼠标点击控制台中的链接，即可在浏览器中打开这个站点：\n配置主题 主题文件夹其实类似一个站点模板，这里将主题文件夹下的配置文件hugo.yaml及examplesite目录下的内容拷贝到我们的站点下，从而达到快速应用主题的目的。\n下载主题：点击链接[hugo stack](Hugo Themes)，找到stack主题下载后解压缩：然后将主题文件夹复制到之前创建的hugo-test站点目录的themes文件夹下，并将主题文件改名，最后效果如下：\n把主题文件夹hugo-theme-stack中exampleSite\\content\\post路径下的rich-content目录删掉，然后把hugo-theme-stack\\exampleSite\\下面的content目录和hugo.yaml复制到hugo-test站点目录下，最后还要把hugo-test目录下的hugo.toml文件删掉\n打开hugo.yaml，确认里面的theme节点的配置使用的站点目录下themes目录里面的主题文件夹名即： 重新启动站点服务，查看效果： 1 hugo server -D github部署 这里我们介绍如何使用github管理hugo站点并且自动化发布站点应用\n创建github pages类型的仓库 创建一个以{github用户名}.github.io命名的仓库，就会被github认为你创建了一个静态页面网站；github会以https://仓库名 作为静态网站的地址，仓库创建后稍后可访问。\n上传hugo站点文件到仓库 在本地hugo-test目录下，创建一个.gitignore文件，添加以下内容： 1 2 3 4 5 6 7 # 自动生成的文件 public resources .hugo_build.lock # hugo命令 hugo.exe 通过以上操作，将站点自动生成的文件如：public发布目录、.hugo_build.lock自动生成文件 等进行了过滤；这些文件不提交至远程仓库\n创建本地仓库，然后将本地仓库上传至远程仓库 1 2 3 4 5 git init git add . git commit -m \u0026#34;first commit\u0026#34; git remote add origin {你的github仓库地址} git push -u origin mater 创建github workflows 在远程仓库使用Github Actions创建一个工作流，来帮助我们自动发布编写的博客：当我们在本地写好一篇博客，推送至远程时，触发工作流最后是实现自动部署。这里我的workflows目录下，需要填写的内容摘抄自另外一个github博主【[.github/workflows/deploy.yml](byjrk.github.io/.github/workflows/deploy.yml at master · BYJRK/byjrk.github.io)】。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 name: Deploy to Github Pages on: push: branches: [master] pull_request: branches: [master] jobs: build: runs-on: ubuntu-latest permissions: # Give the default GITHUB_TOKEN write permission to commit and push the # added or changed files to the repository. contents: write steps: - uses: actions/checkout@v4 with: fetch-depth: 0 - name: Cache Hugo resources uses: actions/cache@v4 env: cache-name: cache-hugo-resources with: path: resources key: ${{ env.cache-name }} - uses: actions/setup-go@v5 with: go-version: \u0026#34;1.24.0\u0026#34; - run: go version - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;0.139.4\u0026#34; extended: true - name: Build run: hugo --minify --gc - name: Deploy 🚀 uses: JamesIves/github-pages-deploy-action@v4 with: branch: gh-pages folder: public clean: true single-commit: true 上面的工作流配置，可直接拷贝。大致效果就是，实际部署时将文件发布到了另外一个[gh-pages]分支上。\n在本地新增一篇文章上传测试自动部署效果 创建一篇新的博客 1 hugo new content post/testblog/index.md 使用编辑器打开该目录下的index.md文件，编辑好博客内容后。\n本地启动查看效果 1 hugo server -D 推送至远程观察工作流 1 2 3 git add. git commit -m \u0026#34;post blog\u0026#34; git push -u origin master 添加评论系统 hugo默认集成的是disqus评论系统，但是这里我推荐使用的是giscus评论系统：因为它简单、容易继承。\n如何引入giscus 选择一个仓库：这里就用博客所在的仓库，我的博客仓库是https://github.com/bigbosscyb/bigbosscyb.github.io 安装giscus app 点击安装会提示选一个仓库，选择上一步指定的仓库就行。\n开启Discussions 填写仓库地址获取评论系统配置信息 按照上述步骤操作完成后，便可以得到下面配置信息：\n将红框内的配置信息复制，然后替换博客所在仓库的主题文件夹下的评论/服务/giscus.yaml文件的这一段内容： 修改博客所在仓库根目录下的hugo.yaml文件，将评论系统从disqus改为giscus 提交修改后，待自动部署完成后可看到博客中出现评论功能：\n添加图床功能 这部分功能再新开一个文章继续介绍，不然文章篇幅太长了，会让人看不下去~\n使用github仓库当图床? 使用cloudflare R2当图床！ ","date":"2025-06-14T14:14:01+08:00","permalink":"https://bigbosscyb.github.io/p/%E4%BD%BF%E7%94%A8hugo%E5%86%99%E5%8D%9A%E5%AE%A2/","title":"使用hugo写博客"}]